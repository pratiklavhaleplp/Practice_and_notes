- Creating a object.
    ```
    var test = {}; -> will create a empty object.
    var test = {
        name : "pratik",
        age : "27"
    }; -> will create a object with name and age property. 
    ```
    ```
    var test = {};
    console.log(typeof test === "object");
    console.log(typeof test);

    <!-- output -->
    true
    object
    ```
- Adding new properties to object.
    ```
    var test = {};
    test.name = "pratik";
    test.age = "27";
    console.log(test);

    <!-- output -->
    { name: 'pratik', age: '27' }
    ```
- Deleting existing property.
    ```
    var test = {};
    test.name = "pratik";
    test.age = "27";
    delete test.name;
    delete test.name;
    console.log(test);

    <!-- output -->
    { age: '27' }

    Discussion: You must have noticed that delete operator is not throwing any error as we are deleting "name" property twice. For the first instance it's ok property is there but next time also delete is not throwing any error, that is the nature of delete operator.
    ```
- Using this in the object
    ```
    let test = {
    name: "pratik",
    innerTest : {
        name: "rutvik",
        fullName: function(){
            console.log(this.name + " " + "lavhale");
            }
        }
    }
    test.innerTest.fullName();

    <!-- output -->
    rutvik lavhale

    Discussion: We are using "this" inside innerTest object which is nested inside test object hence we are getting reference of innerTest in "this".
    ```
- Cunstructor functions
    ```
    function UserInfo(){
    this.name = 'pratik';
    this.address = 'gadge nagar';
    }
    let rutvikInfo = new UserInfo();
    rutvikInfo.name = 'rutvik';
    rutvikInfo.address = 'gadge nagar';
    rutvikInfo.age = '24';
    let defaultUser = new UserInfo();
    console.log('default UserInfo is : ', defaultUser);
    console.log('rutvik UserInfo is : ', rutvikInfo);

    <!-- output -->
    default UserInfo is :  UserInfo { name: 'pratik', address: 'gadge nagar' }
    rutvik UserInfo is :  UserInfo { name: 'rutvik', address: 'gadge nagar', age: '24' }


    Discussion: UserInfo is a constructor function by default if you are creating a object through this then you will get 
        UserInfo { name: 'pratik', address: 'gadge nagar' } OBJECT

    If you are creating a new object as we have created rutvikInfo and assign new values to it then new values will get assigned and you will get a object in the memory it's not a reference its a object created with new memory space. New rutvikInfo object will look like.
        UserInfo { name: 'rutvik', address: 'gadge nagar', age: '24' } OBJECT
    age is a new property that we can add if required with the help of "." operator.

    - You can not create a constructor function with the help of arrow operator.

    - Inside constructor function the value of this is refering to current function i.e, it would be empty object. And a function becomes a constructor function if you are creating a instance of function with the help of "new" operator.

    Please follow proper naming conventions while creating constructor functions you should make UpperCase first character of your constructor function.
    ```
    ```
    function userInfo() {
    console.log('this here is : ', this);
    this.name = 'pratik';
    this.address = 'gadge nagar';
    }
    userInfo();

    <!-- Output -->
    this here is [WINDOW OBJECT]


    Discussion: Above funtion is not a constructor function as we have not created a instance with the help of new keyword.
    ```
    ```
    function userInfo() {
    console.log('this here is : ', this);
    this.name = 'pratik';
    this.address = 'gadge nagar';
    }
    userInfo();
    let rutvikInfo = new userInfo();

    <!-- Output -->
    this here is : [WINDOW OBJECT]
    this here is :  userInfo {}
    userInfo { name: 'pratik', address: 'gadge nagar' }


    Discussion: At first we have only called userInfo function there it is normal javascript funtion, now after using new with the userInfo for that line it is working as constructor function.
    ```
- **The Global Object**. The host environment(browser, node, etc) provides a global object and that global object provides multiple important properties. you can access global object with the help of **"this"** operator outside any constructor function or outside any function.
    ```
    <!-- We are using host here browser -->
    var a = 1;
    console.log(window.a);
    console.log(this.a);

    <!-- output -->
    1
    1
    ```
- The **Constructor** property
    ```
    function userInfo(name = '', age = ''){
    this.name = name;
    this.age = age;
    }
    let pratik = new userInfo('pratik', '27');
    let rutvik = new pratik.constructor('rutvik', '24');

    console.log('Constructor', pratik.constructor);
    console.log('Pratik object', pratik);
    console.log('Rutvik object', rutvik);

    <!-- output -->
    Constructor [Function: userInfo]
    Pratik object userInfo { name: 'pratik', age: '27' }
    Rutvik object userInfo { name: 'rutvik', age: '24' }


    Discussion: When you create a object with the constructor function that object has a property called "constructor". "constructor" property has the reference of your CONSTRUCTOR FUNCTION(userInfo) check how we have created rutvik object.
    ```
- **instanceOf Operator**
    ```
    function userInfo(name = "", age = ""){
    this.name = name;
    this.age = age;
    }
    let pratik = new userInfo("pratik", "27");
    console.log('is pratik instance of userInfo? ', pratik instanceof userInfo);

    <!-- output -->
    is pratik instance of userInfo true


    Discussion: instaceof will return true or false please check above example carefully.
    ```

- **Functions that returns Object**
    ```
    function userInfo(name = "", age = "") {
    return {
        name: name,
        age: age
        }
    }
    let pratikInfo = userInfo("pratik", "27");
    console.log("pratik info is : ", pratikInfo);
    console.log("constructor of pratik is", pratikInfo.constructor);
    console.log("is pratik instance of userInfo? ", pratikInfo instanceof userInfo);

    <!-- output -->
    pratik info is :  { name: 'pratik', age: '27' }
    constructor of pratik is [Function: Object]
    is pratik instance of userInfo?  false


    Discussion: every time you call the function it'll return you a new new object. Check carefully what instanceof and constructor properties are used in the code.
    ```
- **Passing objects**
    ```
    let testObj = {
        name: "pratik",
        age: "27"
    }
    function test(obj){
        console.log('Received object is ', obj);

        // modifying testObj here
        obj.age = "40";
    }
    test(testObj);
    console.log(testObj);

    <!-- output -->
    Received object is  { name: 'pratik', age: '27' }
    { name: 'pratik', age: '40' }

    Discussion: testObj is passed by reference. So if you made any modificaiton in the object then it'll get reflected to the orignal object.
    ```
- **Comparing Objects** If you are comparing two objects and if they are refering to same object then and then only **"==="** will yeil true else it will yeild false.
    ```
    let pratik = {
    age: 27,
    address: "gadge nagar"
    };
    let pratikClone = {
        age: 27,
        address: "gadge nagar"
    };

    if(pratik === pratikClone){
        console.log("equal");
    }else{
        console.log("not equal")
    }

    <!-- output -->
    not equal


    Discussion: The reason for not equal is, pratik and pratikClone are not refering to same object.
    ```
- **Object literals**
    ```
    let a = 1, b = 2;
    let objOld = {a: a, b: b};
    let objNew = { a, b};
    console.log('Old object',objOld);
    console.log('New object',objNew);

    <!-- output -->
    Old object { a: 1, b: 2 }
    New object { a: 1, b: 2 }


    Discussion: Both the ways we can create objects. We are creating objects just by giving key values which is way we create objects with literals. 
    ```
    ```
    let obj = {
    name: "pratik",
    test(){
        console.log('testing');
        }
    }
    obj.test();

    <!-- output -->
    testing


    Discussion: we added function in the object obj without using function keyword.
    ```
- **Object properties and attributes** Each Object can have properties or it might be the empty object. If Object is having properties then each property in the object has two attributes.
    - Enumerable(boolean): Indicates that you properties can be itterate or not with the help of Object.keys
    - Configurable(bolean): If false then you can not delete or modify any property in the object.
    ```
    let userInfo = {
        name : "pratik",
        age : 27
    }
    cosole.log(userInfo.Object.getOwnPropertyDescriptor(userInfo, 'name'));

    <!-- output -->
    {
    value: 'pratik',
    writable: true,
    enumerable: true,
    configurable: true
    }


    Discussion: So here we have userInfo object inside it we have name property and we can configure and  enumerate this name property.
    ```
    ```
    let userInfo = {
    name: "pratik",
    age: 27,
    address: {
        pin: 444603
        }
    }
    Object.defineProperty(userInfo, 'name', { configurable: false, writable: false, enumerable: true });
    Object.defineProperty(userInfo, 'address', { configurable: false, writable: false, enumerable: true });
    userInfo.name = "rutvik";
    console.log('userInfo is : ', userInfo);

    <!-- output -->
    userInfo is :  { name: 'pratik', age: 27, address: { add: 'gadgeNagar' } }


    Discussion: If you could see we have changed the name property but it did not got updated because we have set writable as "false" which makes the name property not to change in any scenario.
    ```

- **ES6 Object methods** Es6 introduces **static methods for objects**. Object.assign is a helper method which will help us to shallow copy the object properties.
    - **Object.assign** This is a static method check the upper case of "Object"
        ```
        let userInfo = {};
        Object.assign(userInfo, { name: "pratik" });
        console.log('Added one property name to the target Obj [userInfo]: ',userInfo);

        Object.assign(userInfo, { age: 27 }, { address: { pin: 444603, landMark: "gadge nagar" } });
        console.log('Added properties from multiple source and target Obj is [userInfo]: ',userInfo);

        <!-- output -->
        Added one property name to the target Obj [userInfo]:  { name: 'pratik' }
        Added properties from multiple source and target Obj is [userInfo]:  {
        name: 'pratik',
        age: 27,
        address: { pin: 444603, landMark: 'gadge nagar' }
        }

        
        Discussion: We added properties or assigned proeprties to out Target object userInfo. We can have multiple source objects and one source object please check 2nd Object.assign method where we have added address and age carefully.
        ```
        - **Only Enumerable own (non-inherited) properties can be copied using Object.assign(). Properties from Prototype chain are not considered while adding property using Object.assign method.**
            ```
            let userInfo = { age: 27 };
            Object.defineProperty(userInfo, 'address', {enumerable : true});
            console.log('Enumurable set to true: ',userInfo);

            <!-- output -->
            Enumurable set to true:  { age: 27, address: undefined }


            Discussion: Carefully check the output we are making enumerable as true because of same reason we are getting address in the userInfo object such "object's" property are considered in Object.assign
            ```
            ```
            let userInfo = { age: 27 };
            Object.defineProperty(userInfo, 'address', {enumerable : false});
            console.log('Enumurable set to true: ',userInfo);

            <!-- output -->
            Enumurable set to true:  { age: 27 }


            Discussion: Carefully check the output we are making enumerable as false because of same reason we are not getting address in the userInfo object such "object's" property are not considered in Object.assign
            ```

    - **Object.is** Compare object with this method.
        ```
        console.log('With === NaN: ',NaN === NaN);
        console.log('With === -0 +0: ',-0 ==== +0);

        console.log('With Object.is NaN: ',Object.is(NaN, NaN));
        console.log('With Object.is -0 +0: ',Object.is(-0,+0));

        <!-- output -->
        With === NaN:  false
        With === -0 +0:  true
        With Object.is NaN:  true
        With Object.is -0 +0:  false


        Discussion: === sometimes may create confussion so Object.is would be best solution for such confussion. Again Object.is does not solve out problem of **deep equality or same content different reference objects**
        ```
        - Check this example.
            ```
            let pratikUserInfo = {
                name: "pratik",
                age: 27
            };
            let defaultUserInfo = {
                name: "pratik",
                age: 27
            };

            if(pratikUserInfo === defaultUserInfo){
                console.log("Both the objects are equal");
            }else{
                console.log("Objects are not equal");
            }

            if(Object.is(pratikUserInfo, defaultUserInfo)){
                console.log("Both the objects are equal with Object.is");
            }else{
                console.log("Objects are not equal with Object.is"); 
            }

            <!-- output -->
            Objects are not equal
            Objects are not equal with Object.is


            Discussion: If you could see over here both the objects are equal but still you are getting both the objects are not equal even with Object.is this is the problem of object equality currently i'm facing. We'll look for the solution on this further.
            ```

- **Desctructuring**
    ```
    let userInfo ={
    name: {
        firstName: "pratik",
        lastName: "lavhale"
    },
    address: "gadge nagar near radhakrishna temple amravati.",
    age: "27"
    }

    let {address : userAddress, age: userAge} = userInfo;
    console.log('address is : ', userAddress);
    console.log('age is : ', userAge);

    <!-- output -->
    address is :  gadge nagar near radhakrishna temple amravati.
    age is :  27


    Discussion: Check carefully how we have destructured address and age we have given local names like userAaddress and userAge and loged them out.
    ```
    ```
    let days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
    let [, , , thuVar] = days;
    console.log(thuVar);

    <!-- output -->
    thu

    
    Discussion: Check carefully how we have destructured thu here we gave thuVar directly as a local variable name and we have got thu assigned to thuVar.
    ```
- **Built in Objects** built in objects can be divided into three groups
    - Data wrapper objects: These are Object, Array, Boolean, String, Function, Number
    - Utility objects: Math, Date and RegExp
    - Error objects: This include general Error object and this object will help you to recover your state of program after getting some errors or issues.

    - **Object** is the parent object of all javascript objects. Which ever object you create in javascript that object is inheritated from **Object**. 
        ```
        let obj = {};
        let objTest = new Object();

        Discussion: Both above lines are same. i.e, {} and new Object will create a object in the memory.
        ```
        - **{}** is not useless, as we know that {} is not having any properties of it's own but still has some inherited properties.
            ```
            let obj = {};
            let objTest = new Object();

            console.log('obj', obj.constructor());
            console.log('obj', obj.toString());
            console.log('obj', obj.valueOf());

            console.log('objTest', objTest.constructor());
            console.log('objTest', objTest.toString());
            console.log('objTest', objTest.valueOf());

            <!-- output -->
            obj {}
            obj [object Object]
            obj {}
            objTest {}
            objTest [object Object]
            objTest {}


            Discussion: Both obj and objTest are created differently. Both the objects are empty and still having constructor(), toString(), valueOf() methods inside it.
            ```
    - **Array** Array() is a built in constructor which you can use to create a array. 
        ```
        let testArr1 = new Array();
        let testArr2 = new Array(1, 2, 'three',  'four');
        console.log('test Array1 : ', testArr1);
        console.log('test Array2 : ', testArr2);
        console.log(testArr1.constructor());
        console.log(testArr1.length);

        <!-- output -->
        test Array1 :  []
        test Array2 :  [ 1, 2, 'three', 'four' ] 
        [Function: Array]   
        0


        Discussion: Array's are objects but are of special type. 
            1. Arrays has length property
            2. The name of the properties are assigned automatically 0,1,2,3,4,...
            3. Array's have more built in methods then normal objects.
        ```

        - **Array Methods** 
        ```
        let arr = new Array(3,1,2,7,5,6,4);
        arr.push(8);
        console.log('pushing 8 : ', arr);
        arr.pop();
        console.log('popping last : ', arr);
        arr.sort();
        console.log('sorting arr : ', arr);
        let slicedArr = arr.slice(1,3);
        console.log(slicing 1  to  3 : arr);
        let joinedArr = arr.join(' .. ');
        console.log('joining arr with .. ', arr);

        <!-- output -->
        pushing 8 :  [
        3, 1, 2, 7,
        5, 6, 4, 8
        ]
        popping last :  [
        3, 1, 2, 7,
        5, 6, 4
        ]
        sorting arr :  [
        1, 2, 3, 4,
        5, 6, 7
        ]
        Orignal arr :  [
        1, 2, 3, 4,
        5, 6, 7
        ] and sliced arr from 1  to  3 : [ 2, 3, 4 ]
        Orignal arr :  [
        1, 2, 3, 4,
        5, 6, 7
        ] and joining arr with ..  1 .. 2 .. 3 .. 4 .. 5 .. 6 .. 7


        Discussion: slice, join methods are not going to change contents in the orignal array they are going to return you the array with the effect of the slice and join.
            Check carefully slice method this method has two parameters both we have to pass index. Slice will give you a array starting from the first parameter and will end till one index before the 2nd parameter.
        ```
        - **ES6 Array Methods** 
            - **Array.from** is a way to convert array like objects into Array.
                ```
                function createArray(){
                    return Array.from(arguments);
                }
                let testArr = createArray(1,2,3,4,5,"test");
                console.log(testArr);

                <!-- output -->
                [ 1, 2, 3, 4, 5, 'test' ]


                Discussion: arguments is the default parameter what we have in any function so what ever we are passing with createArray method that is getting catched into arguments and from that new array has got created.
                ```
            - **Array.of** Array.of creates an array from its arguments, regardless of their number and type of arguments.
                ```
                let arr = Array.of(1,"2",{name : "pratik"});
                console.log(arr);

                <!-- output -->
                [ 1, '2', { name: 'pratik' } ]
                ```
            - **Array.prototype methods** All below methods return an iterator. This iterator can be used to create array with the help of Array.from() and can be used in the for loop for iteration.
                - Array.prototype.entries()
                - Array.prototype.values()
                - Array.prorotype.keys()
                    ```
                    let arr = ['one', 'tow', 'three', 'four', 'five'];
                    for(const index of arr.keys()){
                        console.log('indexes of arr : ', index);
                    }

                    for(const values of arr.values()){
                        console.log('values of arr : ', values);
                    }

                    for(const [index,value] of arr.entries()){
                        console.log(index,value);
                    }

                    <!-- output -->
                    indexes of arr :  0
                    indexes of arr :  1
                    indexes of arr :  2
                    indexes of arr :  3
                    indexes of arr :  4

                    values of arr :  one
                    values of arr :  tow
                    values of arr :  three
                    values of arr :  four
                    values of arr :  five

                    0 one
                    1 tow
                    2 three
                    3 four
                    4 five
                    ```
                - Array.prototype.find
                - Array.prototype.findIndex
                    ```
                    let arr = [1, 2, 7, 4, 5, 6, 3, 8, 9, 10];
                    console.log(arr.find((ele, index, testArr) => { return ele > 2 }));
                    console.log(arr.findIndex((ele, index, testArr) => { return ele === 3 }));

                    <!-- output -->
                    7
                    6


                    Discussion: Both the mehtods has two arguments first is the callback function and another is the optional this keyword. The callback accepts three arguments the array element, index of that element and the array. Call back shoud return true or false.

                    If you could see find will work sequentially after 2 we have 7 which is higher than 2.
                    ```
    - **Function** is a special data type. Actually functions are objects. There is built in constructor called Function() which will create a function if needed. But creating a function with the help of Funciton() constructor is not recommended.
        ```
        function test(a, b){
            return a+b;
        }
        console.log('Sum through normal function : ', test(10,15))
        let sum = new Function('a', 'b', 'return a + b;');
        console.log('Sum through Fuction constructor : ',sum(10,15));

        <!-- output -->
        Sum through normal function :  25
        Sum through Fuction object :  25
        ```
        - **Properties of Funcitons** like every other objects in javascripit we have constructor property for Funciton. No matter how you create a function you will get the same result if you are accessing cinstructor property.
            ```
            function test(a,b,c){
                console.log(a,b,c)
            };
            let testFun = new Function('a','b','c','console.log(a,b,c)');
            console.log('constructor property of Function : ', testFun.constructor);
            console.log('constructor property of test : ', test.constructor)
            console.log('length property of function : ', test.length);

            <!-- output -->
            constructor property of Function :  [Function: Function]
            constructor property of test :  [Function: Function]
            3


            Discussion: Every function has a property length which will help you to get idea on how many arguments are there in the function parameter list.
            ```
            - **Using the prototype property** One of the most widely used property of functions is prototype.
                - The prototype property of funciton will point to another object.
                - prototype shines only when you are using function as a constructor.
                - All the objects created with this function keep reference to the prototype property and can use its properties as there own.
                ```
                let userInfo = {
                        name: "prabhudas lavhale",
                    sayMyName: function(){
                        return "my name is : " + this.name;
                    }
                }
                function F(){};
                console.log('inside of F.prototype : ', F.prototype);
                console.log('type of F prototype : ', F.prototype);
                F.prototype = userInfo;
                let pratikUserInfo = new F();
                console.log('name from parent userInfo for pratik : ',pratikUserInfo.name);
                console.log('say my name from parent userInfo for pratik : ', pratikUserInfo.sayMyName);

                let rutvikUserInfo = new F();
                rutvikUserInfo.name = "BABA";
                console.log('name from parent userInfo for rutvik : ',rutvikUserInfo.name);
                console.log('say my name from parent userInfo for rutvik : ', rutvikUserInfo.sayMyName);
                console.log('name from parent user info for pratik : ',pratikUserInfo.name);                         

                <!-- output -->
                inside of F.prototype :  {}
                type of F prototype :  {}
                name from parent userInfo for pratik :  prabhudas lavhale
                say my name from parent userInfo for pratik :  [Function: sayMyName]
                name from parent userInfo for rutvik :  BABA
                say my name from parent userInfo for rutvik :  [Function: sayMyName]
                name from parent userInfo for pratik :  prabhudas lavhale


                Discussion: 
                    First we created parent userInfo object. 
                    
                    Second we create a empty "F" function. Now we know that every object has prototype property F function is also having one. F's prototype is empty object {} and the type of this {} is "object". we are assigning userInfo to F's prototype. 
                    
                    Third we create a new function pratikUserInfo with the help if new F(). This is where magic happens now you can access name, sayMyName of parent object userInfo. Same you can check with rutvikUserInfo. 

                    One important thing we are not sharing userInfo object among pratikUserInfo and rutvikUserInfo. As and when F() is getting called a new userInfo has been getting created so there will be seprate copies of userInfo for rutvikUserInfo and pratikUserInfo. Check carefully for pratikUserInfo name property and rutvikUserInfo name property both are having different values. we modified rutvikUserInfo.name as "BABA".
                ```
        
        - **Methods of Funciton** we have **.toString()**, **call()** and **apply()** methods for javascript funciton. 
            ```
            function test(){
                console.log("testing");
            }
            console.log("test function toString : ", test.toString());

            let userInfo = {
                name: "pratik lavhale",
                say: function sayMyName(who){
                    console.log(who + " is calling " + " My name is : " + this.name);
                    return 0;
                }
            }

            console.log(userInfo.say('rutvik'));
            let testObj = {name : "rutvik"};
            userInfo.say.call(testObj, "cooler wala");
            userInfo.say.apply(testObj, ["cooler wala"]);
            
            <!-- output -->
            test function toString :  function test(){
                console.log("testing");
            }
            rutvik is calling  My name is : pratik lavhale
            0 // because of return 0
            cooler wala is calling  My name is : rutvik


            Discussion: call and apply works same manner but the only difference is that while using apply you need to pass arguments inside array of other object.
